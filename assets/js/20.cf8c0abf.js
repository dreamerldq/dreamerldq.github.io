(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{147:function(e,n,t){"use strict";t.r(n);var r=t(0),s=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"redux源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redux源码解析","aria-hidden":"true"}},[e._v("#")]),e._v(" Redux源码解析")]),t("p",[e._v("获取源码渠道： NPM 下载redux    node_modules => redux => src 中就能找到你想要的。")]),t("h2",{attrs:{id:"createstore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createstore","aria-hidden":"true"}},[e._v("#")]),e._v(" createStore")]),t("p",[e._v("下方代码是createStore函数的源码。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export default function createStore(reducer, preloadedState, enhancer) {\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n")])])]),t("p",[e._v("createStore函数接受三个参数， 第一个参数是reducer函数，用来改变store的状态，第二个参数是默认值，是一个对象（对象的原型指向Object），第三个参数是enhancer函数，这是一个高阶函数，作用是在原有的createStore的基础上做加强。")]),t("p",[e._v("上面这段代码对传入createStore函数的参数做了判断。如果 preloadedState是一个函数 并且 enhancer是undefined（没有此参数），那么，就默认第二个参数就是enhancer，讲默认值赋值为undefined。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.')\n  }\n")])])]),t("p",[e._v("如果传入的enhancer和reducer不是函数的话， 报错，要求必须是函数类型。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n  function getState() {\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      )\n    }\n\n    return currentState\n  }\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n   \n")])])]),t("p",[e._v("subscribe这个函数用来监听currentState的变化，接受一个参数作为回调函数。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'\n      )\n    }\n\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'\n        )\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n    }\n  }\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      )\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      )\n    }\n")])])]),t("p",[e._v("dispatch函数是唯一能改变currentState值得方式。函数接收一个对象，对象必须具备type属性。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n")])])]),t("p",[e._v("发送dispatch后，执行reducer函数。这里先简单展示下reducer的基本结构。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" const reducer = (state, action) => {\n     switch(action.type){\n         case: 'example':\n         return {...state, property: action.}\n     }\n }\n")])])]),t("p",[e._v("这里返回的数据将会用来更新currentState。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n")])])]),t("p",[e._v("当currentState改变之后，就会执行用户用来监听数据变化的listener函数")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    currentReducer = nextReducer\n    dispatch({ type: ActionTypes.REPLACE })\n  }\n\n  \n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      \n      subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.')\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState())\n          }\n        }\n\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n")])])]),t("h2",{attrs:{id:"combinereducers-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#combinereducers-函数","aria-hidden":"true"}},[e._v("#")]),e._v(" combineReducers 函数")]),t("h3",{attrs:{id:"assertreducersshape函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#assertreducersshape函数","aria-hidden":"true"}},[e._v("#")]),e._v(" assertReducersShape函数")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    const type =\n      '@@redux/PROBE_UNKNOWN_ACTION_' +\n      Math.random()\n        .toString(36)\n        .substring(7)\n        .split('')\n        .join('.')\n    if (typeof reducer(undefined, { type }) === 'undefined') {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle ${\n            ActionTypes.INIT\n          } or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n")])])]),t("p",[e._v("获取所有Reducer的KEY值")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n")])])]),t("p",[e._v("通过判断将所有的非函数的reducer剔除掉，然后将剩下的保存在finalReducerKeys属性中。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nlet unexpectedKeyCache\nif (process.env.NODE_ENV !== 'production') {\n  unexpectedKeyCache = {}\n}\n\nlet shapeAssertionError\ntry {\n  assertReducerShape(finalReducers)\n} catch (e) {\n  shapeAssertionError = e\n}\n\nreturn function combination(state = {}, action) {\n  if (shapeAssertionError) {\n    throw shapeAssertionError\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const warningMessage = getUnexpectedStateShapeWarningMessage(\n      state,\n      finalReducers,\n      action,\n      unexpectedKeyCache\n    )\n    if (warningMessage) {\n      warning(warningMessage)\n    }\n  }\n\n  let hasChanged = false\n  const nextState = {}\n  for (let i = 0; i < finalReducerKeys.length; i++) {\n    const key = finalReducerKeys[i]\n    const reducer = finalReducers[key]\n    const previousStateForKey = state[key]\n    const nextStateForKey = reducer(previousStateForKey, action)\n    if (typeof nextStateForKey === 'undefined') {\n      const errorMessage = getUndefinedStateErrorMessage(key, action)\n      throw new Error(errorMessage)\n    }\n    nextState[key] = nextStateForKey\n    hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n  }\n  return hasChanged ? nextState : state\n}\n}\n")])])]),t("p",[e._v("返回一个combine函数，作为createStore的reducer。\n然后combine在处理每一个action的时候，便利所有的reducer，让所有的reducer都执行，然后将执行后的结果根据state的key值和reducer的key值做匹配，返回一个新的state。（遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用）")])])}],!1,null,null,null);n.default=s.exports}}]);
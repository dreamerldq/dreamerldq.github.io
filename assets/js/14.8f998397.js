(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{153:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"lazy-load实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lazy-load实现","aria-hidden":"true"}},[e._v("#")]),e._v(" lazy-load实现")]),n("ul",[n("li",[e._v("html5懒加载实现")]),n("li",[e._v("微信小程序懒加载实现")])]),n("h2",{attrs:{id:"微信小程序懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#微信小程序懒加载","aria-hidden":"true"}},[e._v("#")]),e._v(" 微信小程序懒加载")]),n("p",[e._v("监听页面的scroll事件,判读元素距离页面的top值是否是小于等于页面的可视高度")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("showImg(){\n\tlet group = this.data.group\n\tlet height = this.data.height  // 页面的可视高度\n\t\n\twx.createSelectorQuery().selectAll('.item').boundingClientRect((ret) => {\n\t ret.forEach((item, index) => {\n\t   if (item.top <= height) { 判断是否在显示范围内\n\t     group[index].show = true // 根据下标改变状态\n\t   }\n\t })\n\t this.setData({\n\t   group\n\t })\n\t}).exec()\n\n}\nonPageScroll(){ // 滚动事件\n\tthis.showImg()\n}\n\nonload(){\n     wx.getSystemInfo({  // 获取页面可视区域的高度\n      success: (res) =>{\n        this.setData({\n          height: res.screenHeight\n        })\n}\n")])])]),n("p",[e._v("通过"),n("code",[e._v("getSystemInfo")]),e._v("可以获取到设备的信息，在这里我们主要用到设备的屏幕尺寸信息。\n使用"),n("code",[e._v("createSelectorQuery().selectAll()")]),e._v("函数可以获取到指定的节点，并通过"),n("code",[e._v("boundingClientRect")]),e._v("来获取节点的信息\n在每次滚动页面的时候，调用showimg函数，遍历判断每一个节点距离屏幕顶部的高度是否小于屏幕的高度（以此来判断节点是否进入了屏幕可视范围中），然后将对应的ing显示出来。")]),n("h3",{attrs:{id:"实现方式2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现方式2","aria-hidden":"true"}},[e._v("#")]),e._v(" 实现方式2")]),n("p",[e._v("在微信api中其实提供了一些页面元素交叉的api")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Page({\n  onLoad: function(){\n    wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {\n      res.id // 目标节点 id\n      res.dataset // 目标节点 dataset\n      res.intersectionRatio // 相交区域占目标节点的布局区域的比例\n      res.intersectionRect // 相交区域\n      res.intersectionRect.left // 相交区域的左边界坐标\n      res.intersectionRect.top // 相交区域的上边界坐标\n      res.intersectionRect.width // 相交区域的宽度\n      res.intersectionRect.height // 相交区域的高度\n    })\n  }\n})\n")])])]),n("p",[n("code",[e._v("relativeToViewport")]),e._v(" 交叉区域的参照元素就是屏幕的可视区域。 "),n("code",[e._v("observe用来设置被监听的元素， 回调函数中的参数对象提供了一些基本信息")]),e._v(" ，一旦被监听的元素进入了可是区域，就可以实现是否显示图片的判断。")]),n("h2",{attrs:{id:"html5中的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#html5中的实现","aria-hidden":"true"}},[e._v("#")]),e._v(" HTML5中的实现")]),n("p",[e._v("浏览器中也提供了类似的api \t"),n("code",[e._v("Intersection Observer API")]),e._v(" 使用方式和小程序中的"),n("code",[e._v("createIntersectionObserver")]),e._v(" 类似")])])}],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{155:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"react全局通知（reactdom-render）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react全局通知（reactdom-render）","aria-hidden":"true"}},[e._v("#")]),e._v(" React全局通知（ReactDom.Render）")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Notifcations = ({message, description}) => {\n  return(\n    <div className={styles.container}>\n        <div className={styles.title}>{message}</div>\n        <div className={styles.des}>{description}</div>\n    </div>\n  )\n}\n")])])]),n("p",[e._v("使用函数创建React无状态组件。")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Notifcation = React.createElement( // 将传递的参数，以props的方式传递给通知组件\n      Notifcations,\n      {\n        message,\n        description\n      }\n    )\n")])])]),n("p",[e._v("利用React.createElement动态创建全局通知的视图组件，传递相关的props属性。")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    const node = document.createElement('div') // 创建一个盒子，用来渲染通知组件\n    node.id=`notice${this.count}` // 给这个盒子标记id\n    body.appendChild(node) // 添加在通知列表中\n  ReactDOM.render(Notifcation, document.getElementById(`notice${this.count}`)); // 将React组件渲染在dom中\n")])])]),n("p",[e._v("动态给dom元素中添加创建后的通知节点元素。ReactDom.render主要用来将React组件渲染在DOM中，并且在之后，还会监听react组件的更新。\n一下为完整代码")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react'\nimport styles from './index.scss'\nimport ReactDOM from 'react-dom'\n\nlet body = null\nconst topBody = document.querySelector('body')\nconst notification = { // notification是一个对外的接口对象\n  children: [],\n  count: 0,\n  open({message, description, duration}){\n    const childLen = this.children.length\n    if(childLen === 0){ // 当调用时，如果当前通知队列为空，则在root dom下创建通知元素\n      body = document.createElement('div')\n      body.id = 'notification'\n      topBody.appendChild(body)\n      // 组件的样式请自定义\n    }\n    this.count += 1\n    const Notifcation = React.createElement( // 将传递的参数，以props的方式传递给通知组件\n      Notifcations,\n      {\n        message,\n        description\n      }\n    )\n    const node = document.createElement('div') // 创建一个盒子，用来渲染通知组件\n    node.id=`notice${this.count}` // 给这个盒子标记id\n    body.appendChild(node) // 添加在通知列表中\n    this.children.push(Notifcation)\n    setTimeout(() => {\n      body.removeChild(node)\n      this.children.pop()\n      const length = this.children.length\n      if(length === 0){\n        topBody.removeChild(body)\n      }\n    }, (duration || 4.5) * 1000);\n  ReactDOM.render(Notifcation, document.getElementById(`notice${this.count}`)); // 将React组件渲染在dom中\n  }\n}\nconst Notifcations = ({message, description}) => { // 创建全局通知组件\n  return(\n    <div className={styles.container}>\n        <div className={styles.title}>{message}</div>\n        <div className={styles.des}>{description}</div>\n    </div>\n  )\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  HuaNotification.open({\n        message: 'Notification Title 1',\n        description: 'I will never close automatically. I will be close automatically. I will never close automatically.',\n        duration: 3\n      })\n")])])])])}],!1,null,null,null);t.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{145:function(n,a,e){"use strict";e.r(a);var t=e(0),i=Object(t.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this.$createElement,a=this._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"web-audio-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-audio-api","aria-hidden":"true"}},[this._v("#")]),this._v(" Web Audio API")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[this._v("window.onload = function(){\n  var audioCtx = new (window.AudioContext || window.webkitAudioContext)(); \n  const myAudio = document.getElementById('my_audio') // 获取audio资源\n  var analyser = audioCtx.createAnalyser(); // 创建一个AnalyserNode 节点\n\n  var source = audioCtx.createMediaElementSource(myAudio); // 关联声源\n  \n  var gainNode = audioCtx.createGain();\n  source.connect(analyser); // 将AnalyserNode节点连接到声源\n  source.connect(gainNode);\n  gainNode.connect(audioCtx.destination); // 将声音输出到扬声器\n\n  analyser.fftSize = 2048; // AnalyserNode 将在一个特定的频率域里使用Fast Fourier Transform (FFT) )来捕获音频数据，这取决于你给 AnalyserNode.fftSize 属性赋的值（如果没有赋值，默认值为2048）。\n  var bufferLength = analyser.fftSize\n  var dataArray = new Uint8Array(bufferLength); // 创建一个bufferLength长度的数组， 后续用来存储声音数据\n  const canvas = document.getElementById('my_canvas')\n  const  canvasCtx = canvas.getContext(\"2d\");\n  const WIDTH = canvasCtx.canvas.width;\n  const HEIGHT = canvasCtx.canvas.height;\n  canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\n\n  function draw() {\n    drawVisual = requestAnimationFrame(draw); // requestAnimationFrame 这是HTML5提供的一个新的api，作用类似于settimeout，不过时间和当前电脑的帧率相关\n    analyser.getByteTimeDomainData(dataArray);// getByteTimeDomainData 获取到音频数据，然后传递给指定的数组\n      canvasCtx.fillStyle = 'rgb(200, 200, 200)';\n      canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n      canvasCtx.lineWidth = 2;\n      canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\n\n      canvasCtx.beginPath();\n      var sliceWidth = WIDTH * 1.0 / bufferLength;\n      var x = 0;\n      for(var i = 0; i < bufferLength; i++) {\n   \n        var v = dataArray[i] / 128.0; //128为基线\n        var y = v * HEIGHT/2; // 居中\n\n        if(i === 0) {\n          canvasCtx.moveTo(x, y);\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n\n        x += sliceWidth;\n      }\n      canvasCtx.lineTo(WIDTH, HEIGHT/2);\n      canvasCtx.stroke();\n\n  }\n  draw();\n}\n\nfunction setGainNode(){\n  let value = 0\n   const timer =  setInterval(()=>{\n    value += 0.1\n     if(value >=1){\n       clearInterval(timer)\n     }\n    gainNode.gain.value = value\n  },1000)\n  gainNode.gain.valeu = 1\n}\n")])])])])}],!1,null,null,null);a.default=i.exports}}]);